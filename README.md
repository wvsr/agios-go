### **1.1. Vision**

This document specifies the architecture for a next-generation AI Search Engine. Our vision is to create a user experience that is **transparent, intelligent, and perceptually instantaneous.** It will compete with best-in-class products like Perplexity by providing rich, multi-modal answers that include text, web results, interactive widgets, and deep analysis.

### **1.2. Architectural Pillars**

Our architecture is founded on three unwavering principles:

1. **Progressive Revelation & Transparency:** We banish static loading spinners. The system's **Chain of Thought (COT)** is streamed live to the user, providing constant feedback and building trust by showing _how_ we derive an answer.
2. **Unified Block-Based Rendering:** All content—whether received in real-time via SSE or loaded from history via a GET request—is represented as a standardized `Block`. This is the cornerstone of our architecture, guaranteeing a consistent UI and dramatically simplifying frontend development.
3. **Modular & Extensible Orchestration:** The backend is a central **Orchestrator** that intelligently invokes a suite of **Tools** (Web Search, Widgets, the Synthesizer). This design ensures we can rapidly add new capabilities in the future without re-architecting the core system.

### **2. The User Experience Journey (Detailed Flows)**

### **2.1. Flow A: The Initial "Synthesizer" Search (Deep Analysis)**

This flow is for complex queries requiring web search and analysis.

1. **Query:** User types "What were the key takeaways from Apple's last earnings call?" and hits Enter.
2. **Instant UI Response:** The page immediately displays a `PLAN` block.
3. **Live COT Stream:** The `PLAN` block updates in real-time, showing the backend's "thoughts":
   - `[✓] Parsing query`
   - `[...in progress] Searching the web for "Apple Q1 2025 earnings call summary"`
4. **Streaming Results:** A new `WEB_RESULTS` block appears. Links to sources populate this block one-by-one as they are discovered, complete with citation numbers.
5. **Answer Streaming:** A `MARKDOWN_ANSWER` block appears. The main textual summary, generated by the LLM, streams in word-by-word, with citations `[1]`, `[2]` appearing as the text is written.
6. **Synthesizer COT & Execution:** The `PLAN` block updates again: `[...in progress] Synthesizing key metrics and takeaways`.
7. **Structured Data Appears:** A `SYNTHESIZER_RESULTS` block materializes, displaying rich UI cards for **Key Metrics** (e.g., `Title: iPhone Revenue`, `Value: $43.8B`) and **Key Takeaways**. This block's data appears all at once after the Synthesizer tool completes its analysis.
8. **Completion:** The `PLAN` block marks all steps as complete. A `RELATED_QUERIES` block is populated.

### **2.2. Flow B: The Follow-up "Widget" Search (Direct Answer)**

1. **Query:** On the same page, the user asks, "what is apple stock price now?".
2. **New COT Plan:** A new `PLAN` block appears: `[...in progress] Analyzing for specialized tools`.
3. **Widget Trigger:** The plan updates instantly: `[✓] Identified Finance intent`, `[...in progress] Fetching live stock data`.
4. **Widget First:** A `FINANCE_WIDGET` block appears almost immediately, displaying the current AAPL price, a chart, and key stats. This high-value, structured data is prioritized.
5. **Contextual Text:** A simple `MARKDOWN_ANSWER` block streams in a brief text like, "Here is the current stock information for Apple Inc. (AAPL)."

### **2.3. Flow C: Loading a Conversation from History (Instant Reconstruction)**

1. **Navigation:** User opens a bookmarked URL (e.g., `/search/apple-earnings-takeaways-uuid`).
2. **Single API Call:** The frontend makes a single `GET /api/v1/threads/{threadId}` request.
3. **Instant Render:** The API returns a single JSON array containing all messages for the thread. Each `assistant` message object contains a fully populated `response_blocks` array. The frontend iterates this static data and renders the _exact same_ block components used in the real-time flows, resulting in an immediate and perfectly preserved view of the conversation.

### **3. System Architecture Overview**

### **3.1. High-Level Diagram**

```
+----------------+   +-------------------+   +-----------------------+
| User's Browser |<->| API Gateway / CDN |<->|  Backend Application  |
| (React/Vue/etc)|   | (CORS, Caching)   |   | (Node.js/Go/Python)   |
+----------------+   +-------------------+   +-----------+-----------+
    | (HTTP/SSE)                                         |
    V                                                    V
+----------------------------------------+     +-----------------------+
|     Frontend State Management          |     | Request Orchestrator  |
| - Handles SSE Events                   |     | - Creates Plan (COT)  |
| - Manages Block State                  |     | - Executes Tools (DAG)|
| - Renders Blocks                       |     | - Streams Responses   |
+----------------------------------------+     +-----------+-----------+
                                                           | (Invokes)
                 +----------------+-----------+-----------+
                 |                |           |           |
                 V                V           V           V
          +------------+   +------------+   +---------+   +--------------+
          | Web Search |   | Widget     |   | LLM     |   | Synthesizer  |
          | Tool       |   | Tools      |   | Engine  |   | Tool (LLM)   |
          +------------+   +------------+   +---------+   +--------------+
                                   |
                                   V
                          +-------------------+
                          |  PostgreSQL DB    |
                          | (Threads,Messages)|
                          +-------------------+

```

### **3.2. Component Responsibilities**

- **Frontend:** The client-side application (e.g., React) responsible for rendering the UI, managing user input, and handling the SSE connection to update the view in real-time.
- **API Gateway:** The public-facing entry point that handles routing, rate limiting, SSL termination, and CORS policies. It directs traffic to the Backend Application.
- **Backend Application:** The core of the system, written in a language like Node.js, Go, or Python. It houses the Orchestrator and API logic.
- **Request Orchestrator:** The "brain" of the application. For each user query, it classifies intent, creates a dynamic plan of execution, invokes the necessary tools in parallel, and streams the results back to the client in a structured format.
- **Tools:** Modular, independent services or clients that perform specific tasks. This includes fetching web search results, calling external APIs for widgets (Weather, Finance), or running specialized LLM prompts (Synthesizer).
- **Database:** A PostgreSQL instance used as the persistent datastore for conversation threads, messages, and associated file metadata.

### **4. The Core Data Model: The Universal "Block"**

### **4.1. The Block Interface: The Unifying Primitive**

The `Block` is the atomic unit of content in our system. It is a self-contained, renderable piece of the UI. This model is the key to unifying our real-time and historical data flows.

```tsx
interface Block {
  blockId: string // Unique ID for this block instance (e.g., 'plan-msg2')
  blockType: BlockType // Enum determining the UI component to render
  status: 'streaming' | 'complete' | 'failed'
  payload: any // Data structure specific to the blockType
}
```

### **4.2. Complete Block Type Specification & Payloads**

This table defines the precise schema for the `payload` of each `blockType`.

| `blockType`           | `payload` Schema                                                                                                                                                             | Description                                            |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| `PLAN`                | `{ steps: [{ text: string, status: 'in_progress' \| 'complete' \| 'failed' }] }`                                                                                             | The live-updating Chain of Thought (COT) block.        |
| `WEB_RESULTS`         | `{ results: [{ title: string, url: string, snippet: string, citation: number }] }`                                                                                           | A list of web search sources.                          |
| `MARKDOWN_ANSWER`     | `{ content: string }`                                                                                                                                                        | The main textual AI response, streamed token by token. |
| `RELATED_QUERIES`     | `{ queries: string[] }`                                                                                                                                                      | Suggested follow-up questions, generated at the end.   |
| `WEATHER_WIDGET`      | `{ location: string, temperature: string, condition_icon: string, condition_text: string, humidity: string, wind_speed: string, forecast: [{ day: string, temp: string }] }` | Structured data for a weather widget.                  |
| `FINANCE_WIDGET`      | `{ symbol: string, company_name: string, price: number, change: number, change_percent: number, chartData: [{ time: string, value: number }] }`                              | Structured data for a finance/stock widget.            |
| `SYNTHESIZER_RESULTS` | `{ short_summary: string, key_takeaways: [{ text: string, confidence_score: number }], metrics: [{ title: string, value: string }] }`                                        | Structured analytical data from the Synthesizer tool.  |

### **5. Database Schema (PostgreSQL)**

### **5.1. Rationale: Denormalization for Read Performance**

We are intentionally storing the entire final response structure (`response_blocks`) as a single JSONB field in the `messages` table. This violates traditional normalization rules but is a deliberate and critical performance optimization. It allows us to retrieve an entire, complex conversation with a single, fast `SELECT` query, avoiding the slow and expensive `JOIN` operations that a fully relational model would require. This is the optimal strategy for a read-heavy chat application.

### **5.2. `threads` Table**

```sql
CREATE TABLE threads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID, -- Foreign key to a users table
    title VARCHAR(255) NOT NULL,
    url_slug VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

```

### **5.3. `messages` Table**

```sql
CREATE TYPE message_role AS ENUM ('user', 'assistant');
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    thread_id UUID NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
    role message_role NOT NULL,
    query_text TEXT, -- For 'user' roles, this contains the user's typed query.
    response_blocks JSONB, -- For 'assistant' roles, this stores the final, complete array of Blocks as JSON.
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_messages_thread_id_created_at ON messages(thread_id, created_at);

```

### **5.4. `files` Table**

```sql
CREATE TABLE files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
    original_filename VARCHAR(255) NOT NULL,
    storage_path VARCHAR(1024) NOT NULL,
    file_size_bytes BIGINT NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

```

### **6. API Endpoints & Detailed Response Structures**

### **6.1. `POST /api/v1/files/upload`**

- **Description:** Uploads a file for use in a conversation.
- **Request:** `multipart/form-data` containing the file.
- **Response:** `201 Created` with a JSON body containing a secure `fileId`.

**JSON Response Body Example:**

```json
{
  "fileId": "file-a1b2c3d4-e5f6-7890-g1h2-i3j4k5l6m7n8"
}
```

### **6.2. `POST /api/v1/threads`**

- **Description:** Creates a new conversation thread from an initial user query.
- **Request Body:** `{ "query_text": string, "file_ids"?: string[] }`
- **Response:** `200 OK` with `Content-Type: text/event-stream`. The body is an SSE stream as defined in Section 7.

### **6.3. `POST /api/v1/threads/{threadId}/messages`**

- **Description:** Adds a new user query to an existing conversation thread.
- **Request Body:** `{ "query_text": string, "file_ids"?: string[] }`
- **Response:** `200 OK` with `Content-Type: text/event-stream`. The body is an SSE stream as defined in Section 7.

### **6.4. `GET /api/v1/threads/{threadId}`**

- **Description:** Loads the complete history for a conversation. This is the endpoint used when a user navigates directly to a chat URL.
- **Response:** `200 OK` with a JSON body containing an array of message objects.

**Complete JSON Response Body Example:**

This definitive example shows a two-turn conversation, demonstrating a "Synthesizer" flow followed by a "Widget" flow.

```json
[
  {
    "id": "msg-user-7b1b3b1a",
    "thread_id": "thread-a4f6e8c1",
    "role": "user",
    "query_text": "What were the key takeaways from Apple's last earnings call?",
    "response_blocks": null,
    "created_at": "2025-06-18T14:00:00Z"
  },
  {
    "id": "msg-asst-c2d4e6f8",
    "thread_id": "thread-a4f6e8c1",
    "role": "assistant",
    "query_text": null,
    "created_at": "2025-06-18T14:00:18Z",
    "response_blocks": [
      {
        "blockId": "plan-c2d4",
        "blockType": "PLAN",
        "status": "complete",
        "payload": {
          "steps": [
            { "text": "Parsing query", "status": "complete" },
            { "text": "Searching the web for \\"Apple Q1 2025 earnings call summary\\"", "status": "complete" },
            { "text": "Analyzing search results", "status": "complete" },
            { "text": "Generating summary answer", "status": "complete" },
            { "text": "Synthesizing key metrics and takeaways", "status": "complete" }
          ]
        }
      },
      {
        "blockId": "web-c2d4",
        "blockType": "WEB_RESULTS",
        "status": "complete",
        "payload": {
          "results": [
            { "title": "Apple reports first quarter results - Apple", "url": "<https://www.apple.com/newsroom/2025/01/28/apple-reports-first-quarter-results/>", "snippet": "The Company posted quarterly revenue of $123.9 billion, an all-time record...", "citation": 1 },
            { "title": "Key takeaways from Apple's Q1 2025 earnings call - CNBC", "url": "<https://www.cnbc.com/2025/01/28/apple-aapl-q1-2025-earnings.html>", "snippet": "Services revenue grew to $20.8 billion, a significant jump from last year...", "citation": 2 }
          ]
        }
      },
      {
        "blockId": "md-c2d4",
        "blockType": "MARKDOWN_ANSWER",
        "status": "complete",
        "payload": {
          "content": "Apple's first-quarter earnings for fiscal year 2025 set a new all-time revenue record, largely driven by strong performance in both iPhone sales and its growing Services division[1]. The Services segment, in particular, showed significant year-over-year growth, highlighting its increasing importance to Apple's business model[2]."
        }
      },
      {
        "blockId": "synth-c2d4",
        "blockType": "SYNTHESIZER_RESULTS",
        "status": "complete",
        "payload": {
          "short_summary": "Apple achieved a record-breaking quarter with $123.9B in revenue, fueled by robust iPhone demand and a substantial 24% growth in its high-margin Services division.",
          "key_takeaways": [
            { "text": "Services revenue growth is accelerating and is a key factor in profitability.", "confidence_score": 97.2 },
            { "text": "The company successfully navigated supply chain constraints to meet high iPhone demand.", "confidence_score": 94.8 }
          ],
          "metrics": [
            { "title": "Total Revenue", "value": "$123.9B" },
            { "title": "Services Revenue", "value": "$20.8B" },
            { "title": "Gross Margin", "value": "43.8%" },
            { "title": "iPhone Revenue", "value": "$71.6B" }
          ]
        }
      },
      {
        "blockId": "related-c2d4",
        "blockType": "RELATED_QUERIES",
        "status": "complete",
        "payload": {
          "queries": [
            "Apple services segment breakdown",
            "Apple vision pro sales impact",
            "AAPL stock forecast 2025"
          ]
        }
      }
    ]
  },
  {
    "id": "msg-user-9f8e7d6c",
    "thread_id": "thread-a4f6e8c1",
    "role": "user",
    "query_text": "what is apple stock price now?",
    "response_blocks": null,
    "created_at": "2025-06-18T14:02:30Z"
  },
  {
    "id": "msg-asst-5a4b3c2d",
    "thread_id": "thread-a4f6e8c1",
    "role": "assistant",
    "query_text": null,
    "created_at": "2025-06-18T14:02:33Z",
    "response_blocks": [
      {
        "blockId": "plan-5a4b",
        "blockType": "PLAN",
        "status": "complete",
        "payload": {
          "steps": [
            { "text": "Analyzing for specialized tools", "status": "complete" },
            { "text": "Identified Finance intent", "status": "complete" },
            { "text": "Fetching live stock data", "status": "complete" }
          ]
        }
      },
      {
        "blockId": "widget-5a4b",
        "blockType": "FINANCE_WIDGET",
        "status": "complete",
        "payload": {
          "symbol": "AAPL",
          "company_name": "Apple Inc.",
          "price": 195.75,
          "change": 1.25,
          "change_percent": 0.64,
          "chartData": [
             { "time": "09:30", "value": 194.50 },
             { "time": "10:00", "value": 195.10 },
             { "time": "10:30", "value": 195.75 }
          ]
        }
      },
      {
        "blockId": "md-5a4b",
        "blockType": "MARKDOWN_ANSWER",
        "status": "complete",
        "payload": {
          "content": "Here is the current stock information for Apple Inc. (AAPL)."
        }
      }
    ]
  }
]

```

### **7. The SSE Streaming Protocol: The Real-Time Contract**

### **7.1. SSE Event Definitions**

The client will listen for these events on the SSE stream. Each event is a text block in the format `event: <name>\\ndata: <json_payload>\\n\\n`.

| Event Name         | Data Payload Schema                           | Purpose                                                                                                                                |
| ------------------ | --------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `message.created`  | `{ messageId: string }`                       | The very first event. Acknowledges the query and provides the ID for the new assistant message.                                        |
| `block.create`     | `{ block: Block }`                            | A new block is being added. Frontend should render its placeholder.                                                                    |
| `block.update`     | `{ blockId: string, newPayload: any }`        | The payload of an existing block has been updated. Used for COT steps and populating result lists.                                     |
| `chunk.stream`     | `{ blockId: string, chunk: string }`          | A piece of a stream, specifically for the `MARKDOWN_ANSWER` block's text content. Frontend appends this chunk to the existing content. |
| `message.complete` | `{ messageId: string, finalBlocks: Block[] }` | The final event. Signals the end of the response and provides the complete state for archival.                                         |
| `error`            | `{ code: number, message: string }`           | An unrecoverable error occurred.                                                                                                       |

### **7.2. Detailed SSE Flow Walkthrough: A Synthesizer Query**

**Query:** "Nvidia earnings metrics"

```
event: message.created
data: {"messageId":"asst-msg-123"}

event: block.create
data: {"block":{"blockId":"plan-123","blockType":"PLAN","status":"streaming","payload":{"steps":[{"text":"Parsing query","status":"complete"}]}}}

event: block.update
data: {"blockId":"plan-123","newPayload":{"steps":[{"text":"Parsing query","status":"complete"},{"text":"Searching the web...","status":"in_progress"}]}}

event: block.create
data: {"block":{"blockId":"web-123","blockType":"WEB_RESULTS","status":"streaming","payload":{"results":[]}}}

event: block.update
data: {"blockId":"web-123","newPayload":{"results":[{"title":"...","url":"...","citation":1}]}}

event: block.create
data: {"block":{"blockId":"md-123","blockType":"MARKDOWN_ANSWER","status":"streaming","payload":{"content":""}}}

event: chunk.stream
data: {"blockId":"md-123","chunk":"Nvidia's recent earnings were driven by "}

event: block.update
data: {"blockId":"plan-123","newPayload":{"steps":[...,{"text":"Synthesizing key metrics...","status":"in_progress"}]}}

event: block.create
data: {"block":{"blockId":"synth-123","blockType":"SYNTHESIZER_RESULTS","status":"streaming","payload":{}}}

event: block.update
data: {"blockId":"synth-123","newPayload":{"short_summary":"...","key_takeaways":[...],"metrics":[...]}}

event: message.complete
data: {"messageId":"asst-msg-123","finalBlocks":[...]}

```

### **8. The Backend Orchestrator Engine**

### **8.1. Orchestration Lifecycle: From Query to Completion**

The Orchestrator is the heart of the backend logic. For every user query, it performs the following sequence of operations:

1. **Ingestion & Acknowledgement:** It receives the query from the API endpoint. It immediately creates a `user` message and an `assistant` message (with a pending state) in the database. It then sends the `message.created` SSE event to the client to acknowledge receipt.
2. **Classification:** It runs a lightweight model or rule-based classifier on the `query_text` to determine the primary intent (e.g., General Question, Weather, Finance, Analysis).
3. **Planning (COT Generation):** Based on the intent, it constructs a Directed Acyclic Graph (DAG) of tasks to be executed. This plan itself is the first `Block` to be created and streamed to the client via a `block.create` event, providing the initial Chain of Thought.
4. **Asynchronous Execution:** It begins executing the tasks in the DAG, running non-dependent tasks in parallel (e.g., Web Search can run at the same time as an initial LLM brainstorming call). As each task completes or yields data, the Orchestrator streams `block.create` or `block.update` events. It also continuously sends `block.update` events for the `PLAN` block to reflect the current status, which makes the COT feel alive.
5. **Tool Invocation:** For each task, it calls the appropriate, standardized Tool module (e.g., the Web Searcher, Weather API Client, LLM Engine, or the specialized Synthesizer).
6. **Finalization:** Once all tasks in the DAG are complete, the Orchestrator assembles the final, complete array of all generated blocks. It sends this array in the `message.complete` event, which signals the end of the stream. Finally, it updates the `assistant` message in the database, persisting the final `response_blocks` JSON for historical retrieval.

### **9. The Tool System & The "Synthesizer" Tool**

### **9.1. Generic Tool Architecture**

A "Tool" is a self-contained, modular component that the Orchestrator can invoke. Every tool must adhere to a simple, standardized interface: it receives context (such as the user query and data from previous tools) and returns structured data that the Orchestrator can format into a `Block`. This modularity is key to our system's extensibility.

### **9.2. The Synthesizer: A Deep Dive into a Core Feature**

The Synthesizer is not a generic tool; it is a high-value, specialized tool that provides our product with a significant competitive advantage.

- **Purpose:** To elevate our answers beyond simple text by transforming unstructured web content into structured, scannable, and insightful data.
- **Trigger:** The Orchestrator's Classifier invokes the Synthesizer tool for any query that is identified as analytical or summary-based and does not trigger a simple, direct-answer widget.
- **Process:**
  1. **Input:** The Synthesizer receives the original user query, the full text content from the `WEB_RESULTS` block, and often the initial generated text from the `MARKDOWN_ANSWER` block.
  2. **Specialized LLM Call:** It makes a **second, dedicated call** to an LLM. The prompt for this call is highly structured and engineered to force the LLM to act as a data analyst. It specifically instructs the model to return **only a JSON object** with the precise schema defined in Section 4.2 (`{ short_summary, key_takeaways, metrics }`). We will use advanced prompting techniques to enforce constraints, such as the maximum word count for metric titles.
  3. **Output:** The tool parses and validates the returned JSON. It then passes this single, structured object back to the Orchestrator.
- **Result:** The Orchestrator wraps this structured JSON in a `SYNTHESIZER_RESULTS` block and streams it to the client. This allows the frontend to render rich, interactive UI cards, providing a far superior experience to plain text.

### **10. Frontend Implementation Strategy**

### **10.1. State Management: The Key to a Unified UI**

The core state on the frontend will be a map or dictionary where keys are `messageId`s and values are arrays of `Block` objects. This allows for efficient, targeted updates to any block within any message.

```tsx
// Example state structure in a React application using hooks
const [messages, setMessages] = useState<Map<string, Block[]>>(new Map())
```

### **10.2. A Unified Rendering Component (Pseudo-code)**

A top-level component will manage the data fetching (both initial history and live SSE), and a `RenderBlock` component will handle the display logic for each block type.

```tsx
// Pseudo-code for a unified rendering component
function ChatThread({ threadId }) {
  const [messages, setMessages] = useState(new Map<string, Block[]>())

  // Flow C: Initial load from GET request for history
  useEffect(() => {
    async function fetchHistory() {
      const response = await fetch(`/api/v1/threads/${threadId}`)
      const historyMessages = await response.json()
      const initialMap = new Map()
      historyMessages.forEach((msg) => {
        if (msg.role === 'assistant' && msg.response_blocks) {
          initialMap.set(msg.id, msg.response_blocks)
        }
        // User messages can be handled here as well if needed
      })
      setMessages(initialMap)
    }
    fetchHistory()
  }, [threadId])

  // Flows A & B: Connect to SSE for real-time updates for new messages
  useEffect(
    () => {
      // Logic to establish an SSE connection when a new message is sent.
      const sse = connectToNewMessageStream(threadId)

      sse.on('message.created', ({ messageId }) => {
        // Create a new entry in the map for the upcoming blocks
        setMessages((prev) => new Map(prev).set(messageId, []))
      })

      sse.on('block.create', ({ block }) => {
        // Add a new block to its message's array
        setMessages((prev) => {
          const newMap = new Map(prev)
          const currentBlocks = newMap.get(messageId) || []
          newMap.set(messageId, [...currentBlocks, block])
          return newMap
        })
      })

      // ... handlers for 'block.update', 'chunk.stream', etc.
      // These handlers find the correct message and block by ID and update them immutably.

      return () => sse.disconnect()
    },
    [
      /* dependency array tied to new message submission */
    ]
  )

  // Render logic is now simple and unified
  return (
    <div className='chat-container'>
      {[...messages.entries()].map(([messageId, blocks]) => (
        <div key={messageId} className='message-turn'>
          {blocks.map((block) => (
            <RenderBlock key={block.blockId} block={block} />
          ))}
        </div>
      ))}
    </div>
  )
}
```

### **11. Summary of Key Architectural Decisions**

| Decision                             | Rationale                                                                                                                                                                                               |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Universal `Block` Model**          | **Simplifies Frontend.** Creates a single, unified contract for rendering both real-time and historical data, drastically reducing complexity and ensuring UI consistency.                              |
| **Denormalized DB Schema**           | **Optimized for Performance.** Prioritizes fast read speeds for entire conversations, which is the primary access pattern for a chat application. A single `SELECT` is faster than complex `JOIN`s.     |
| **Streaming Chain of Thought (COT)** | **Enhances User Experience.** Provides transparency and a feeling of responsiveness, building user trust and engagement by showing the "work" behind the answer.                                        |
| **Dedicated "Synthesizer" Tool**     | **Adds Unique Value.** Moves beyond simple text answers to provide structured, actionable insights in the form of metrics and takeaways, a key product differentiator.                                  |
| **Event-Driven SSE Protocol**        | **Provides Granular Control.** Allows the frontend to build the UI piece by piece (`block.create`, `block.update`) instead of parsing a monolithic stream, enabling a more dynamic and responsive feel. |
